<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interactive Tone Generator</title>
    <meta name="author" content="beardordie">
    <meta name="description" content="Interactive Multi-Touch Tone Generator with Modes">
    <!-- Twitter Card meta tags -->
    <meta name="twitter:card" content="player" />
    <meta name="twitter:site" content="@DevHobbyist" />
    <meta name="twitter:title" content="Multi-Touch Tone Generator" />
    <meta name="twitter:description" content="This is a Multi-Touch Tone Generator Twitter/X player card." />
    <meta name="twitter:image" content="https://beardordie.github.io/tonegenerator/tonegenerator.png">
    <meta name="twitter:player" content="https://beardordie.github.io/tonegenerator/">
    <meta name="twitter:player:width" content="480" />
    <meta name="twitter:player:height" content="480" />

    <meta name="og:site_name" content="DevHobbyist">
    <meta name="og:title" content="Multi-Touch Tone Generator" />
    <meta name="og:description" content="It's a tone generator that operates via multi-touch." />
    <meta name="og:url" content="https://beardordie.github.io/tonegenerator/">
    <meta name="og:type" content="website">
    <meta name="og:image" content="https://beardordie.github.io/tonegenerator/tonegenerator.png">
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Tone.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        height: 100%;
        font-family: 'Roboto', sans-serif;
      }
      body {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #container {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }
      
      /* Control Panel */
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 100;
      }
      
      .control-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      .btn {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: #eee;
        padding: 8px 14px;
        font-family: 'Roboto', sans-serif;
        font-weight: 700;
        font-size: 12px;
        cursor: pointer;
        border-radius: 6px;
        transition: all 0.2s;
        text-transform: uppercase;
        user-select: none;
      }
      
      .btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.6);
      }
      
      .btn.active {
        background: rgba(0, 200, 150, 0.4);
        border-color: #00c896;
      }
      
      #modeBtn {
        min-width: 100px;
      }
      
      /* Waveform indicator */
      #waveform {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
        color: #eee;
        font-size: 14px;
        font-weight: 700;
        z-index: 100;
      }
      
      #waveformIcon {
        width: 40px;
        height: 20px;
        stroke: #00c896;
        stroke-width: 2;
        fill: none;
      }
      
      /* Instructions */
      #instructions {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-family: 'Roboto', sans-serif;
        font-weight: 400;
        font-size: 11pt;
        color: rgba(255, 255, 255, 0.5);
        pointer-events: none;
        user-select: none;
        text-align: center;
        line-height: 1.5;
      }
      
      #modename {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        margin: 0;
        font-family: 'Roboto', sans-serif;
        font-weight: 900;
        font-size: 24pt;
        color: rgba(255, 255, 255, 0.15);
        pointer-events: none;
        user-select: none;
        text-transform: uppercase;
        text-align: center;
        z-index: 1;
      }
      
      /* Octave display */
      #octaveDisplay {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        color: #00c896;
        font-weight: 700;
        font-size: 16px;
        z-index: 100;
      }
    </style>
    
  </head>
  <body>
    <div id="container">
      <!-- Control Panel -->
      <div id="controls">
        <div class="control-row">
          <button class="btn" id="modeBtn">Mode: Sine</button>
          <button class="btn" id="snapBtn">Snap: Off</button>
        </div>
        <div class="control-row">
          <button class="btn" id="octaveDown">Oct -</button>
          <button class="btn" id="octaveUp">Oct +</button>
        </div>
      </div>
      
      <!-- Waveform Indicator -->
      <div id="waveform">
        <svg id="waveformIcon" viewBox="0 0 40 20">
          <!-- Will be updated based on mode -->
        </svg>
        <span id="waveformName">Sine</span>
      </div>
      
      <span id="modename">Touch to Play</span>
      <span id="octaveDisplay">Octave: 0</span>
      <span id="instructions">X-axis: Frequency | Y-axis: Volume<br>Tap mode button or double-tap to change waveform</span>
    </div>
    
    <script>
      // ============================================
      // MODE DEFINITIONS
      // ============================================
      const Modes = {
        SINE: {
          name: "Sine",
          createOscillator: function(freq) {
            return new Tone.Oscillator(freq, "sine");
          },
          getWaveformPath: function() {
            return "M 0 10 Q 10 0, 20 10 Q 30 20, 40 10";
          }
        },
        SQUARE: {
          name: "Square",
          createOscillator: function(freq) {
            return new Tone.Oscillator(freq, "square");
          },
          getWaveformPath: function() {
            return "M 0 10 L 0 0 L 20 0 L 20 20 L 40 20 L 40 10";
          }
        },
        SAWTOOTH: {
          name: "Sawtooth",
          createOscillator: function(freq) {
            return new Tone.Oscillator(freq, "sawtooth");
          },
          getWaveformPath: function() {
            return "M 0 20 L 20 0 L 20 20 L 40 0";
          }
        },
        TRIANGLE: {
          name: "Triangle",
          createOscillator: function(freq) {
            return new Tone.Oscillator(freq, "triangle");
          },
          getWaveformPath: function() {
            return "M 0 10 L 10 0 L 30 20 L 40 10";
          }
        },
        FM: {
          name: "FM",
          createOscillator: function(freq) {
            const fmo = new Tone.FMOscillator({
              frequency: freq,
              harmonicity: 1,
              modulationIndex: 10,
              type: "sine"
            });
            return fmo;
          },
          getWaveformPath: function() {
            return "M 0 10 C 5 5, 10 15, 15 10 C 20 5, 25 15, 30 10 C 35 5, 40 15, 40 10";
          }
        },
        AM: {
          name: "AM",
          createOscillator: function(freq) {
            const amo = new Tone.AMOscillator({
              frequency: freq,
              harmonicity: 1,
              modulationIndex: 10,
              type: "sine"
            });
            return amo;
          },
          getWaveformPath: function() {
            return "M 0 10 Q 5 5, 10 10 Q 15 15, 20 10 Q 25 5, 30 10 Q 35 15, 40 10";
          }
        }
      };

      const modeKeys = Object.keys(Modes);
      let modeIndex = 0;
      let selectedMode = Modes[modeKeys[modeIndex]];

      // ============================================
      // STATE
      // ============================================
      let currentOctave = 0;
      let snapToNotes = false;
      
      // Musical note frequencies (A4 = 440Hz base)
      const noteFrequencies = {
        'C': 261.63,
        'C#': 277.18,
        'D': 293.66,
        'D#': 311.13,
        'E': 329.63,
        'F': 349.23,
        'F#': 369.99,
        'G': 392.00,
        'G#': 415.30,
        'A': 440.00,
        'A#': 466.16,
        'B': 493.88
      };
      
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

      // ============================================
      // UI UPDATES
      // ============================================
      function updateModeDisplay() {
        document.getElementById('modeBtn').textContent = 'Mode: ' + selectedMode.name;
        document.getElementById('waveformName').textContent = selectedMode.name;
        document.getElementById('waveformIcon').innerHTML = 
          '<path d="' + selectedMode.getWaveformPath() + '" />';
        document.getElementById('modename').textContent = selectedMode.name;
      }

      function updateOctaveDisplay() {
        const sign = currentOctave >= 0 ? '+' : '';
        document.getElementById('octaveDisplay').textContent = 'Octave: ' + sign + currentOctave;
      }

      function cycleMode() {
        modeIndex = (modeIndex + 1) % modeKeys.length;
        selectedMode = Modes[modeKeys[modeIndex]];
        updateModeDisplay();
      }

      // ============================================
      // THREE.JS SETUP
      // ============================================
      let canvasSize;
      const container = document.getElementById('container');

      function updateCanvasSize() {
        const w = container.clientWidth;
        const h = container.clientHeight;
        canvasSize = Math.min(w, h) * 0.9;
      }
      updateCanvasSize();

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(0, canvasSize, canvasSize, 0, -10, 10);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(canvasSize, canvasSize);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      // Grid lines for visual feedback
      const gridMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 });
      
      // Horizontal grid lines (volume zones)
      for (let i = 1; i < 5; i++) {
        const y = (canvasSize / 5) * i;
        const points = [new THREE.Vector3(0, y, -1), new THREE.Vector3(canvasSize, y, -1)];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, gridMaterial);
        scene.add(line);
      }
      
      // Vertical grid lines (frequency zones)
      for (let i = 1; i < 13; i++) {
        const x = (canvasSize / 12) * i;
        const points = [new THREE.Vector3(x, 0, -1), new THREE.Vector3(x, canvasSize, -1)];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, gridMaterial);
        scene.add(line);
      }

      // ============================================
      // TOUCH/MOUSE STATE
      // ============================================
      const activeTouches = {};
      let mouseActive = null;
      let lastTapTime = 0;

      // ============================================
      // VISUAL INDICATORS
      // ============================================
      const colors = [
        0x00ff88, 0xff6b6b, 0x4ecdc4, 0xffd93d, 0xc44dff, 
        0xff9f43, 0x00d2d3, 0x6c5ce7, 0x78e08f, 0xf8b500
      ];

      function createTouchTexture(color) {
        const size = 128;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext("2d");
        
        const r = ((color >> 16) & 255) / 255;
        const g = ((color >> 8) & 255) / 255;
        const b = (color & 255) / 255;
        
        const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        gradient.addColorStop(0, `rgba(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)}, 1)`);
        gradient.addColorStop(0.5, `rgba(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)}, 0.5)`);
        gradient.addColorStop(1, `rgba(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)}, 0)`);
        
        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
      }

      const touchTextures = colors.map(c => createTouchTexture(c));
      let colorIndex = 0;

      function createIndicator() {
        const texture = touchTextures[colorIndex % touchTextures.length];
        colorIndex++;
        
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(40, 40, 1);
        return sprite;
      }

      // ============================================
      // ANIMATION
      // ============================================
      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.005;
        const pulseScale = 2.5 + 0.5 * Math.sin(time);

        for (let key in activeTouches) {
          if (activeTouches[key].indicator) {
            activeTouches[key].indicator.scale.set(40 * pulseScale, 40 * pulseScale, 1);
          }
        }
        if (mouseActive && mouseActive.indicator) {
          mouseActive.indicator.scale.set(40 * pulseScale, 40 * pulseScale, 1);
        }
        renderer.render(scene, camera);
      }
      animate();

      // ============================================
      // AUDIO HELPERS
      // ============================================
      function getFrequency(x, y) {
        const minFreq = 100 * Math.pow(2, currentOctave);
        const maxFreq = 650 * Math.pow(2, currentOctave);
        let freq = minFreq + (x / canvasSize) * (maxFreq - minFreq);
        
        if (snapToNotes) {
          // Find closest note
          let closestNote = null;
          let closestDist = Infinity;
          
          for (const [note, baseFreq] of Object.entries(noteFrequencies)) {
            const freqWithOctave = baseFreq * Math.pow(2, currentOctave);
            const dist = Math.abs(freq - freqWithOctave);
            if (dist < closestDist) {
              closestDist = dist;
              closestNote = freqWithOctave;
            }
          }
          freq = closestNote;
        }
        
        return freq;
      }

      function getVolume(y) {
        // Invert: bottom = quiet (0), top = loud (0.3)
        const normalizedY = 1 - (y / canvasSize);
        return Math.max(0.02, normalizedY * 0.3);
      }

      function getRelativePosition(clientX, clientY) {
        const rect = renderer.domElement.getBoundingClientRect();
        // rect.left/top already account for canvas centering via flexbox
        let x = clientX - rect.left;
        let y = clientY - rect.top;
        
        // Clamp to canvas bounds
        x = Math.max(0, Math.min(canvasSize, x));
        y = Math.max(0, Math.min(canvasSize, y));
        
        return { x, y };
      }

      // ============================================
      // TOUCH HANDLERS
      // ============================================
      function startTouch(touch) {
        Tone.start();
        const pos = getRelativePosition(touch.clientX, touch.clientY);
        const freq = getFrequency(pos.x, pos.y);
        const volume = getVolume(pos.y);
        
        const oscillator = selectedMode.createOscillator(freq);
        const gainNode = new Tone.Gain(0).toDestination();
        
        // Apply envelope for smoother sound
        gainNode.gain.setValueAtTime(0, Tone.now());
        gainNode.gain.linearRampToValueAtTime(volume, Tone.now() + 0.05);
        
        oscillator.connect(gainNode);
        oscillator.start();

        const indicator = createIndicator();
        indicator.position.set(pos.x, canvasSize - pos.y, 0);
        scene.add(indicator);

        activeTouches[touch.identifier] = { oscillator, gainNode, indicator };
      }

      function updateTouch(touch) {
        const pos = getRelativePosition(touch.clientX, touch.clientY);
        const freq = getFrequency(pos.x, pos.y);
        const volume = getVolume(pos.y);
        
        if (activeTouches[touch.identifier]) {
          activeTouches[touch.identifier].oscillator.frequency.value = freq;
          activeTouches[touch.identifier].gainNode.gain.value = volume;
          activeTouches[touch.identifier].indicator.position.set(pos.x, canvasSize - pos.y, 0);
        }
      }

      function endTouch(touch) {
        if (activeTouches[touch.identifier]) {
          const { oscillator, gainNode, indicator } = activeTouches[touch.identifier];
          
          // Smooth release
          gainNode.gain.linearRampToValueAtTime(0, Tone.now() + 0.1);
          
          setTimeout(() => {
            oscillator.stop();
            oscillator.dispose();
            gainNode.dispose();
            scene.remove(indicator);
          }, 150);
          
          delete activeTouches[touch.identifier];
        }
      }

      // Touch events
      renderer.domElement.addEventListener("touchstart", (e) => {
        e.preventDefault();
        
        // Double-tap detection for mode change
        const now = Date.now();
        if (now - lastTapTime < 300 && e.changedTouches.length === 1) {
          cycleMode();
        }
        lastTapTime = now;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
          startTouch(e.changedTouches[i]);
        }
      });

      renderer.domElement.addEventListener("touchmove", (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          updateTouch(e.changedTouches[i]);
        }
      });

      renderer.domElement.addEventListener("touchend", (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          endTouch(e.changedTouches[i]);
        }
      });

      renderer.domElement.addEventListener("touchcancel", (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          endTouch(e.changedTouches[i]);
        }
      });

      // ============================================
      // MOUSE HANDLERS
      // ============================================
      function startMouse(clientX, clientY) {
        Tone.start();
        const pos = getRelativePosition(clientX, clientY);
        const freq = getFrequency(pos.x, pos.y);
        const volume = getVolume(pos.y);
        
        const oscillator = selectedMode.createOscillator(freq);
        const gainNode = new Tone.Gain(0).toDestination();
        
        gainNode.gain.setValueAtTime(0, Tone.now());
        gainNode.gain.linearRampToValueAtTime(volume, Tone.now() + 0.05);
        
        oscillator.connect(gainNode);
        oscillator.start();

        const indicator = createIndicator();
        indicator.position.set(pos.x, canvasSize - pos.y, 0);
        scene.add(indicator);

        mouseActive = { oscillator, gainNode, indicator };
      }

      function updateMouse(clientX, clientY) {
        const pos = getRelativePosition(clientX, clientY);
        const freq = getFrequency(pos.x, pos.y);
        const volume = getVolume(pos.y);
        
        if (mouseActive) {
          mouseActive.oscillator.frequency.value = freq;
          mouseActive.gainNode.gain.value = volume;
          mouseActive.indicator.position.set(pos.x, canvasSize - pos.y, 0);
        }
      }

      function endMouse() {
        if (mouseActive) {
          const { oscillator, gainNode, indicator } = mouseActive;
          
          gainNode.gain.linearRampToValueAtTime(0, Tone.now() + 0.1);
          
          setTimeout(() => {
            oscillator.stop();
            oscillator.dispose();
            gainNode.dispose();
            scene.remove(indicator);
          }, 150);
          
          mouseActive = null;
        }
      }

      renderer.domElement.addEventListener("mousedown", (e) => {
        // Right-click cycles mode
        if (e.button === 2) {
          e.preventDefault();
          cycleMode();
          return;
        }
        startMouse(e.clientX, e.clientY);
      });

      renderer.domElement.addEventListener("mousemove", (e) => {
        if (mouseActive) {
          updateMouse(e.clientX, e.clientY);
        }
      });

      renderer.domElement.addEventListener("mouseup", endMouse);
      renderer.domElement.addEventListener("mouseleave", endMouse);
      
      // Prevent context menu
      renderer.domElement.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      // ============================================
      // UI BUTTON HANDLERS
      // ============================================
      document.getElementById('modeBtn').addEventListener('click', () => {
        cycleMode();
      });

      document.getElementById('snapBtn').addEventListener('click', (e) => {
        snapToNotes = !snapToNotes;
        e.target.textContent = snapToNotes ? 'Snap: On' : 'Snap: Off';
        e.target.classList.toggle('active', snapToNotes);
      });

      document.getElementById('octaveUp').addEventListener('click', () => {
        if (currentOctave < 2) {
          currentOctave++;
          updateOctaveDisplay();
        }
      });

      document.getElementById('octaveDown').addEventListener('click', () => {
        if (currentOctave > -2) {
          currentOctave--;
          updateOctaveDisplay();
        }
      });

      // ============================================
      // RESPONSIVE RESIZE
      // ============================================
      function onWindowResize() {
        updateCanvasSize();
        renderer.setSize(canvasSize, canvasSize);
        camera.left = 0;
        camera.right = canvasSize;
        camera.top = canvasSize;
        camera.bottom = 0;
        camera.updateProjectionMatrix();
      }

      window.addEventListener("resize", onWindowResize);

      // Initialize display
      updateModeDisplay();
      updateOctaveDisplay();
      
    </script>
  </body>
</html>
